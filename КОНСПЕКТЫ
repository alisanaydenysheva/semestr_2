История ОС
ЭВМ первого поколения
ОС пока не существет. В 1943 году появлилась необходимость в увеличении скорости расчета баллистических таблиц, которая составляла 4 года. Джон Мокли и Джон Эккерт разработали первый компьютер - Эниак(электронный дифференциальный анализатор). Скорость одного расчета - 5 минут. Используются лампы. Для перепрограммирования используются перемычки. Данные находятся на перфокартах. Используется десятичная система счисления.
Архитектура фон Неймана
Переход к двоичной системе исчисления. 1 - есть сигнал. 0 - нет сигнала
Вместо перфокарт данные хранятся в памяти
Программы выполняются последовательно
ЭВМ второго поколения
В 50-х годах появляются транзисторы. Плюсы по сравнению с лампами:
Надежность
Транзисторы не выделяют тепло
Большая скорость переключения
Плотная коомпоновка деталей
Недостатки:
Проблемы с соединением
Дороговизна производства
Появление первых алгоротмических языков (COBAL, ALGOL), появление компилятора.
ЭВМ третьего и четвертого поколения
Проблемы: Ответить на вопрос - как на полупроводнике разместить все компонетны. Ответ - использовать фотолитографию Как соеденить между собой элементы. Ответ - напыление алюминия
Плюсы:
Уменьшение цены
Надежность
Ускорение ввода
Появление магнитного диска
Появление мультипрограммирования
Четвертое поколение ЭВМ началось в 70-80 годах:

Появление виртуальной памяти(выполнение нужного участка программы)
Появление концепции базы данных
Появление пк - altair 8800
Появление apple
Появления linux
Идеология Unix:
Программа решает одну задачу
Программы хорошо работают вместе
Поддержка текстовых потоков
Linux
Создатель Linux - Линус Торвальдс
1991 - разработка linux, разработка терминала для получения почты, разработка линус которая запускается Bourne shell
Функции ОС:
Выделение программ
Выделение памяти, загрузка памяти исполняемой программы
Обработка системных вызовов
Ввод и вывод данных
Стандартизированный доступ к устройствам ввода и вывода
Обеспечение безопасности
Организация сетевого стека
Монолитное ядро
По сути одна программа
Одно адресное устройство
Linux
UNIX
Микроядерная архитектура:
Маленькое ядро
Юазовое управление памятью
Управление процессорами времени
Совместимость ОС
Двоичная(компиляция кода без перекомпиляции)
На уровне исходных кодов(перекомпиляция кода)
Абстракция архитектуры
Пользовательские программы
Ядро
Ассемблер
Микрокод
Аппаратное обеспечение
Типы файлов UNIX:
Символьные устройства
Блочные устройства
Каталоги
Ссылки
Именованные каналы
Сокеты
Символьные устройства - вид файла устройства в UNIX/Linux-системах, обеспечивающий интерфейс к устройству, реальному или виртуальному, с возможностью посимвольного обмена информацией. В отличие от блочного устройства символьное устройство, как правило, не обладает возможностями произвольного доступа.

Ссылка в Unix-подобных системах — это своего рода указатель, напоминающий указатели в языках программирования, с той лишь разницей, что он указывает на файл или каталог.

Сокет домена Unix (англ. Unix domain socket, UDS) или IPC-сокет (сокет межпроцессного взаимодействия) — конечная точка обмена данными, подобная Интернет-сокету, но не использующая сетевого протокола для взаимодействия (обмена данными). Используется в операционных системах, поддерживающих стандарт POSIX, для межпроцессного взаимодействия. Корректным термином стандарта POSIX является POSIX Local IPC Sockets.

Командная строка
Исполняемые программы
Функции
Библиотечные вызовы
Специальные файлы
Форматы файлов
Игры
Пакеты макросов и соглашения
Команды администрирования системы
Процедуры ядра
Редактирование и просмотр файлов
less- постраничный просмотр и поиск
file, stat - информация о файле
readlink - получить полное имя файлоа
tail, head - просмотр конца и начала файла. Монитор логов
vi/vim, emacs, nano, mcedit - редактирование текста
split - разбить файл на несколько частей
Файлы
touch - создание файла, если он не существует
cp - копирование файла
mv - перемещение/переименование файла
ln - создает ссылки на файлы
alias - создает алиас для команды
Директории и навигация
cd - переход в другую директорию
ls - отображает содержимое директории
pwd - отображает текущую директорию
readlink - полный путь к файлу
rmdir - удаление директории
mkdir - создание директории
rm - удаление файлов
Права файлов
Чтение
Запись
Исполнение
Распространение прав пользователя
Владелец
Группа
Остальные
Пользователь root имеет доступ на чтение и запись для любого файла
Минимальные права для директории - 5(чтение и выполнение). Без прав на выполнение просмотр атрибутов файлов директории невозможен
rwx Чтение, запись и выполнение
rw- Чтение и запись
r-x Чтение и выполнение
r-- Только чтение
w - показывает, кто залогинен и че он занят
who - Показывает, кто залогинен
wall - отправляет бродкаст-сообщение на все терминалы
useradd - утилита создание пользователя
userdel - утилита удаления пользователя
usermod - утилита изменения аккаунтов пользователя
date - просмотр и установка даты
cal - простой календарь
Поток ввода/вывода
STDIN(0) - Стандартный ввод. Файл, из которого осуществляется чтение.
STDOUT (1) - стандартный вывод. Файл, в который осуществляется запись.
STFERR (2) - Стандартный поток ошибок. Файл, в который осуществляется запись сообщений об ошибках
Перенаправление ввода с клавиатуры в файл: command < filename
“l” symlink символическая ссылка. С помощью символических ссылок администратор может присвоить одному файлу или директории несколько идентичностей. Символическая ссылка является указателем на оригинальный файл. Существует два типа символических ссылок: - жесткие ссылки; - мягкие ссылки.
Различие между твердыми и мягкими ссылками в том, что мягкие ссылки ссылаются на имя файла, в то время как жесткие ссылки прямо ссылаются на оригинальный файл. Кроме того, жесткие ссылки не работают с файлами, расположенными на других разделах или файловых системах.
Устройства
Устройства делятся на два типа:

Символьные устройства - последовательный поток данных байт за байтом. Только одна позиция текущая. Невозможно обратиться к случайным данным.
Блочные устройства - позволяют обращаться к данным случаным образом(не последовательно). Блочные устройства чувствительны к производительности. Должны иметь возможность представлять доступ по любому адресу в устройстве.
Сектор - наименьший адресуемый элемент блочного устройства. Стандартый размер - 512 байт(в современных дисках - 4кб). Устройство не может работать с элементом данных размером менее сектора. Для ядра и ПО минимально адресуемая еденица данных для блочного устройства - блок. Размер сектора кратен размеру блока(512б, 1кб, 4кб). Размер блока не больше размера страницы памяти.

Устройства
Файловая система отправляет запросы к устройству в очередь.

Очередь содержит список запросов на ввод/вывод и управляющую информацию.

Пока очередь не пуста, драйвер устройства извлекает запросы из очереди и отправляет на блочное устройство

Файловые системы
Файловая система - способ отображения физических данных в файлы.

Задачи файловой системы:

Отображение логического представления файлов на физическое(сектора на блочном устройстве)
Реализация пользовательского интерфейса для доступа к файлам
Упорядочивание файлов
Защита данных в случае аппаратного сбоя
Реализация контроля доступа к файлам
Иерархия файловой системы
В Windows иерархия файловой системы начинается с имени логического диска

В Linux иерархия представляет единое дерево:

/ - корень файловой системы
/boot - файлы загрузчика и ядро
/etc - конфигурационные файлы
/usr, /usr/local - программы пользователя
/bin, /usr/bin - исполняемые файлы
/home - домашние каталоги пользователей
Абсолютные и относительные пути к файлу
Имена файлов и директорий регистрозависимы. Файлы Temp.txt и temp.txt - это разные файлы.

Абсолютный путь к файлу - путь от корня файловой системы

Относительный путь к файлу - путь от некорневого католога

Основные элементы файловой системы: inode
Индексный дискриптор(inode) содержит метаданные о файлах. Одному файлу соответствует один inode.

inode содержит:

Тип файла, атрибуты и правда доступа
Идентификатор владельца и группы
Число ссылок на файл
Массив адресов блоков файла
Время доступа к файлу, модификация файла, модификации inode
Не содержит:

Имя файла(содержится в блоке данных каталога, который также имеет свой inode)
Данные файла(содержатся в блоках данных файла)
Типы файлов:
Обычные файлы
Директории
Ссылки
Сокеты
Каналы
Файлы символьного устройства
Файлы блочного устройства
Прерывания. Планировщик процессов
Сигналы
Сигналы - способ оповестить процесс о наступлении события. Используются для управления процессами и межпроцессорного взаимодействия.

Каждый сигнал имеет обработчик по умолчанию и действие по умолчанию.

Обработчик сигнала можно переопределить.

Сигналы можно игнорировать, кроме SIGKILL и SIGSTOP.

Прерывания
Прерывания - события, требующие немедленной реакции со стороны со стороны процессора

Виды прерываний:

Аппаратные - поступают от устройств в любой момент времени
Программные - возникают при выполнении программы, синхронно.
Маскируемые - процессор может игнорировать или откладывать их обработку
Немаскируемые - не могут быть проигнорированы
Обычно связаны с аппаратными сбоями: ошибки датчика температуры, ошибки контроллера памяти

Планировщик процессов
Планировщик - компонент ядра, который определяет следующий процесс на выполнение. Планировщик определяет из списка готовых к выполнению задач наиболее подходящую. Процессы, не готовые к выполнению блокируются, используя ядро.

Вытеснение процесса
Linux - ОС с вытесняющей многозадачностью.

Процесс A выполняется
Процесс B переходит в статус "готов к выполнению"
Ядро обнаруживает, что B имеет приоритет больше, чем A
Вызывается планировщик, вытесняет процеcc A
Процесс B ставится на выполнение
Синхронизация процессов в ОС
Синхронизация процессов, определяется как механизм, который гарантирует, что два или более параллельных процесса или потока не смогут одновременно выполнить определенный сегмент программы, т.н. критическую секцию. Доступ процессов в критическую секцию осуществляется с помощью методов синхронизации. Когда кто-то приступает к выполнению критических секций (по частям сегмент программы) другой поток должен ждать, пока первый поток не завершит. Если синхронизация применяется неправильно может возникнуть состояние гонки, в котором значения переменных могут измениться непредсказуемо и изменяться в зависимости от времени переключения процессов или потоков.

Мьютексы
Мьютекс - примитив синхронизации, обеспечивающий взаимное исключение исполнения критических участков кода. Классический мьютекс отличается от двоичного семафора наличием эксклюзивного владельца, который и должен его освобождать (т.е. переводить в незаблокированное состояние). От спинлока мьютекс отличается передачей управления планировщику для переключения потоков при невозможности захвата мьютекса. Встречаются также блокировки чтения-записи, именуемые разделяемыми мьютексами и предоставляющие помимо эксклюзивной блокировки общую, позволяющую совместно владеть мьютексом, если нет эксклюзивного владельца.

Условно классический мьютекс можно представить в виде переменной, которая может находиться в двух состояниях: в заблокированном и в незаблокированном. При входе в свою критическую секцию поток вызывает функцию перевода мьютекса в заблокированное состояние, при этом поток блокируется до освобождения мьютекса, если другой поток уже владеет им. При выходе из критической секции поток вызывает функцию перевода мьютекса в незаблокированное состояние. В случае наличия нескольких заблокированных по мьютексу потоков во время разблокировки планировщик выбирает поток для возобновления выполнения (в зависимости от реализации это может быть, как случайный, так и детерминированный по некоторым критериям поток).

Задачей мьютекса является защита объекта от доступа к нему других потоков, отличных от того, который завладел мьютексом. В каждый конкретный момент только один поток может владеть объектом, защищённым мьютексом. Если другому потоку будет нужен доступ к данным, защищённым мьютексом, то этот поток блокируется до тех пор, пока мьютекс не будет освобождён. Мьютекс защищает данные от повреждения в результате асинхронных изменений (состояние гонки), однако при неправильном использовании могут порождаться другие проблемы, например, взаимная блокировка или двойной захват.

По типу реализации мьютекс может быть быстрым, рекурсивным или с контролем ошибок.

Семафоры
Семафор - примитив синхронизации работы процессов и потоков, в основе которого лежит счётчик, над которым можно производить две атомарные операции: увеличение и уменьшение значения на единицу, при этом операция уменьшения для нулевого значения счётчика является блокирующейся. Служит для построения более сложных механизмов синхронизации и используется для синхронизации параллельно работающих задач, для защиты передачи данных через разделяемую память, для защиты критических секций, а также для управления доступом к аппаратному обеспечению.

Вычислительные семафоры используются для контроля над ограниченными ресурсами. Двоичные семафоры обеспечивают взаимное исключение исполнения критических секций[4], а их упрощённой реализацией являются мьютексы, которые более ограничены в использовании. Помимо взаимного исключения в общем случае семафоры и мьютексы могут использоваться во множестве других типовых алгоритмов, включая сигнализирование другим задачам, разрешение прохождения определённых контрольных точек только для одной задачи единовременно по аналогии с турникетом, задачу производителя и потребителя, подразумевающую передачу данных от одних задач другим, барьеры, позволяющие синхронизировать группы задач в определённых контрольных точках, условные переменные для оповещения других задач о каких-либо событиях и блокировки чтения и записи, разрешающие одновременное чтение данных, но запрещающих их одновременное изменение

Типовыми проблемами использования семафоров являются одновременное блокирование двух задач в ожидании друг друга[ и ресурсное голодание, в результате чего ресурс может быть периодически недоступен для одних задач из-за его использования другими задачами. При использовании в процессах с приоритетом реального времени может возникнуть инверсия приоритетов, которая может привести к неограниченной по времени блокировке процесса с более высоким приоритетом из-за захвата семафора процессом с более низким приоритетом, в то время как процессорное время отдаётся процессу со средним приоритетом, решением чего является наследование приоритетов.

Критические секции
Критическая секция (critical section) - это участок кода, требующий монопольного доступа к каким-то общим данным (ресурсам), которые не должен быть одновременно использованы более чем одним потоком исполнения. При нахождении в критической секции более одного процесса возникает состояние «гонки». Для избежания данной ситуации необходимо выполнение четырех условий:

Два процесса не должны одновременно находиться в критических областях.
В программе не должно быть предположений о скорости или количестве процессоров.
Процесс, находящийся вне критической области, не может блокировать другие процессы.
Невозможна ситуация, в которой процесс вечно ждет попадания в критическую область.
Файловые блокировки
Блокировка файла (англ. file locking) — механизм, который ограничивает доступ к файлу, давая доступ в данный момент только одному пользователю или процессу. Системы реализуют блокировку для предотвращения классического interceding update сценария (который является типичным примером состояния гонки) посредством принуждения к последовательным процессам обновления любого файла.

Следующий пример демонстрирует проблему interceding update:

Процесс A читает запись о клиенте из файла, содержащего бухгалтерскую информацию, включая остаток денег на счете клиента и его номер телефона.
Процесс B тогда же читает ту же самую запись из того же файла, так что у него есть своя копия записи.
Процесс A изменяет остаток на счете в своей копии записи и записывает её обратно в файл.
Процесс B, который все ещё имеет изначальное значение остатка на счете в своей копии записи, обновляет остаток и пишет обратно в файл.
В итоге процесс B записал свое неактуальное значение остатка в файл, приведя к потере изменений, сделанных процессом A.
Неправильное использование блокировки файла, как и любой блокировки, может привести к снижению производительности или взаимной блокировке.

RabbitMQ
RabbitMQ - это брокер сообщений с открытым исходным кодом.

кратко работу RabbitMQ можно описать следующим образом:

Издатель отправляет сообщение определенном обменику;
Обменник, получив сообщение, маршрутизирует его в одну или несколько очередей в соответствии с правилами привязки между ними и очередью;
Очередь хранит ссылку на это сообщение. Само сообщение хранится в оперативной памяти или на диске;
Как только потребитель готов получить сообщение из очереди, сервер создает копию сообщения по ссылке и отправляет её;
Потребитель получает сообщение и отправляет брокеру подтверждение;
Брокер, получив подтверждение, удаляет копию сообщения из очереди. Затем удаляет из оперативной памяти и с диска.
Docker
Docker - программное обеспечение с открытым исходным кодом, применяемое для разработки, тестирования, доставки и запуска веб-приложений в средах с поддержой контейнеризации. Он нужен для более эффективного использовния системных ресурсов, быстрого развертывания готовых программных продуктов, а также для их масштабирования и переноса в другие среды с гарантированным сохранением стабильной работы

Компоненты Docker
Docker-демон - сервер контейнеров, входящий в состав программных средств Docker. Демон управляет Docker-объектами(сети, хранилища, образы и контейнеры)

Docker-клиент(Docker-client/CLI) - интерфейс взаимодействия пользователя с Docker-демоном.

Docker-образ(Docker-image) - файл, включающий зависимости, сведения, конфигурацию для дальнейшего развертывания и инициализации контейнера.

Docker-файл(Docker-file) - описание правил по сборке образа, в котором первая строка указывает на базовый образ. Последующие команды выполняют копирование файлов и установку программ для создания определенной среды для разработки.

Docker-контейнер(Docker-container) - это легкий, автономный исполняемый пакет программного обеспеспечения, который включает в себя все необходимое для запуска приложения: код, среду выполнения, системные иструменты, системные библиотеки и настройки.

Как работает Docker
Пользователь отдает команду с помощью пользовательского интерфейсу Docker-демону, развернутому на Docker-хосте. Например, скачать готовый образ из реестра (хранилища docker-образов)

Что происодит при запуске контейнера
Происходит запуска образа (Docket-image), Docker Engine проверяет существование образа. Если образ уже существует локально, Docker использует его для нового конейнера. При его отсутствии выполняется скачивание с Docker Hub.

InfluxDB
InfluxDB - БД временных рядов, предстваляют собой системы баз данных, специально предназначенные для обработки информации, связанной со временем.

Зачем нужны базы данных временных рядов
При добавлении новых записей в реляционную БД и при наличии в таблице индексов СУБД ьудет многократно переиндексирвоать данные для быстрого и эффективого доступа к ним. Как следствие, производительность со временем снижается. При этом увеличивается нагрузка, что приводит к трудностям при чтении данных.

База данных временных рядов оптимизирована для быстрого приёма данных. Такие системы используют индексацию данных, объединенных со временем. Как следствие, скорость загрузки не уменьшается со временем и остается достаточно
